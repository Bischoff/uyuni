#!/usr/bin/env python
# pylint: disable=missing-module-docstring,invalid-name

import sys
import os
# pylint: disable-next=unused-import
import re
# pylint: disable-next=unused-import
import logging
# pylint: disable-next=unused-import
import traceback
# pylint: disable-next=unused-import
import configparser
import urllib.parse

sys.path.append("/usr/share/rhn/")
# pylint: disable-next=wrong-import-position
from spacewalk.satellite_tools.ulnauth import ULNAuth

# for testing add the relative path to the load path
if "spacewalk-uln-resolver" in sys.argv[0]:
    sys.path.insert(
        0, os.path.join(os.path.dirname(os.path.abspath(__file__)), "../python")
    )

# pylint: disable-next=wrong-import-position
from zypp_plugin import Plugin


class SpacewalkULNPlugin(Plugin):
    """
    ULN authentication Plugin
    """

    def __init__(self):
        Plugin.__init__(self)
        self._uln_auth = ULNAuth()

    # pylint: disable-next=unused-argument
    def RESOLVEURL(self, headers, body):
        """
        Resolve URL.

        :returns: None
        """
        try:
            self._uln_auth.authenticate(headers["url"])
            self.auth_headers = {"X-ULN-Api-User-Key": self._uln_auth.token}
        # pylint: disable-next=broad-exception-caught
        except Exception as exc:
            self.answer("ERROR", {}, str(exc))
        # pylint: disable-next=unused-variable
        hostname, label = self._uln_auth.get_hostname(headers.pop("url"))
        url = self._uln_auth.url + "/XMLRPC/GET-REQ/" + label
        if headers:
            # pylint: disable-next=consider-using-f-string
            url += "?{}".format(urllib.parse.urlencode(headers))
        self.answer("RESOLVEDURL", self.auth_headers, url)


plugin = SpacewalkULNPlugin()
plugin.main()
